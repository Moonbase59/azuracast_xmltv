#!/usr/bin/env python3
# encoding: utf-8

# azuracast_xmltv
# grabs EPG info from an AzuraCast (web radio) instance
# and provides an XMLTV.xml type listing
#
# Note: Requires Python 3.7 or newer (for correct strftime/strptime handling).
#
# One AzuraCast instance can have multiple stations (= "channels").
# Each station can have multiple mounts, which we ignore for EPG purposes,
# since they are supposed to play the same content.
# The XMLTV EPG will contain schedule items for ALL stations,
# since some programs can't handle too many separate EPG files.
#
# Mounts are important for the M3U playlist files, though.
# We will create one M3U playlist file per station (good for resellers,
# or if you want to publicize only certain stations).

# 2023-10-15 - Moonbase59 - initial public version
# 2023-10-16 - Moonbase59 - v0.3.1
#   - rework API access, use a class
# 2023-10-17 - Moonbase59 - v0.4.0
#   - PEP8 formatting
#   - EPG for more than 2 days by repeating the API call
# 2023-10-18 - Moonbase59 - v0.4.1
#   - better HTTP request error handling
# 2023-10-18 - Moonbase59 - v0.5.0
#   - lots of real-life tests, better error handling
#   - tests using the "xmltv-util" package: tv_validate_file, tv_to_text, etc.
#   - work around AzuraCast API quirks (multi-day schedule, duplicates removal)
#   - provide much nicer EPG programme entries if using an API key (=you own station)
#       - customizable Live Show title/sub-title/description (streamer/DJ info)
#       - customizable Live Show DJ info (mis-using Streamer Comment field)
#       - Live Show DJ image (if provided in AzuraCast); this is added as an
#         image of type "person" in the programme's <presenter> info.
#         Not all clients may support this (they'll just ignore it).
#       - customizable listener requests info (for playlists that have requests enabled)
#       - customizable syndication info (for playlists that are remote streams)
# 2023-10-19 - Moonbase59 - v0.5.1
#   - Add 'User-Agent' header for API request, so azuracast_xmltv can be better identified
# 2023-10-19 - Moonbase59 - v0.5.2
#   - Sanitize station name to get RFC2383-compliant (it's user input, after all).
#   - Use 'hostname' instead of 'netloc' to create channel ID; fixes #1.
#     We still leave 'netloc' in the EPG as 'source-info-name' so we know where it
#     really came from.
#   - PEP8 formatting.
# 2023-10-19 - Moonbase - v0.6.0
#   - add option -f/--fillgaps and logic to find gaps between programmes and fill them
#     with dummy entries. This can be used for stations that have a 24/7
#     general rotation and wish to advertise playout in between show blocks.
#     If an API key is used, this can also include the playlist names involved
#     to build the general rotation. Name your playlists appropriately.
#     If ANY of the involved playlists has listener requests enabled,
#     this will be shown (using the requests_enabled parsing).
#   - removed superfluous whitespace in programme description, also eliminating
#     extra spaces/newlines left over from using empty variables.
#   - MUCH improved "{variable}" parsing, and many more that can be used
#   - added append_to_description text that can be added to EVERY programme,
#     can be used for legalese, or website hints.
# 2023-10-21 - Moonbase - v0.7.0
#   - In the M3Us, the mounts are now sorted by their display names,
#     and the default mount put at the beginning.
#     This is intended for players that immediately start playout (they should
#     play the default mount). Human readability also improved by sorting.
#   - -t/--tvurl option: generates 'url-tvg' and 'x-tvg-url' tags on #EXTM3U line,
#     for players like KODI that can thus automatically find the corresponding EPG.
#     Note: ONLY works when the generated M3U and XML files can be found under
#     the '/xmltv/' path on your AzuraCast server, for example at
#     https://example.com/xmltv/example.com.xml.
# 2023-10-22 - Moonbase - v0.8.0
#   - fix {remote_url} showing public player URL
#   - add option -c/--customplayer URL to point to a customized player
#     on a station's website instead of the AzuraCast web player
#     when using the {player_url} or {request_url} variables.
# 2023-10-22 - Moonbase - v0.8.1
#   - minor code refactoring
#   - fix #2 "TypeError: replace() argument 2 must be str, not None"
#     (JSON null strings from API weren’t replaced by an empty string)

# version info
import sys
__version_info__ = ('0', '8', '1')
__version__ = '.'.join(__version_info__)

APPNAME = "azuracast_xmltv"
VERSION = __version__
LICENSE = "MIT"
APPURL = "https://github.com/Moonbase59/azuracast_xmltv"


# *** USER CONFIGURABLE DEFAULTS START HERE ***

# Use the base URL here, NOT the public player URL!
# Note: The AzuraCast demo server is reset on the top of every hour,
# so you might get a CloudFlare Error 521. Just try again a few minutes later.
instance_url = 'https://demo.azuracast.com'

# EPG programme category to list (i.e. "Music", "Talk", ...)
category = 'Music'

# "Moustache-type" variables that can be used when generating programmes:
# Those marked with a * are only available when using an API key,
# i.e. on your own station. They will be empty otherwise.
#
# ALWAYS AVAILABLE:
# - {station_name}
# - {station_description}
# - {station_website} -- the station website URL (not the AzuraCast URL)
# - {player_url}** -- station's web player URL
# - {year} start year of the programme
#
# In "requests_enabled"*:
# - {playlist} -- playlist name
# - {request_url}** -- station's public player URL
#
# In "remote"*:
# - {playlist} -- playlist name
# - {remote_url} -- remote URL used in the playlist
#
# In "live":
# - {presenter} -- streamer/DJ name
# - {image_url}* -- streamer's image URL
# - {comments}* -- AzuraCast's Streamer Comments field content.
#   Comments should be used with care:
#   This field was originally meant for internal remarks only, you could leak data!
#
# In "gap_filler":
# - {playlists}* -- comma-separated list of playlist names that make up the general rotation
#   (enabled, type default, not on schedule).
#   So if your general rotation was made up of the playlists
#   'Classic Rock', 'Folk Rock' and 'Hard Rock', it would show
#   "Classic Rock, Folk Rock & Hard Rock".
#
#  * = This can only be used with an API key, i.e., on your own station.
# ** = Will point to AzuraCast's default web player, or a custom
#      web player URL on the station's website if -c/--customplayer is used.

# Text to add to a programme listing if listener requests are enabled
# for this playlist. Only works with API key.

# this will be used as a programme's title
requests_enabled_title = "{playlist} (requests enabled)"
# this will be used as a programme's subtitle
requests_enabled_subtitle = "Your favorite station, YOUR music!"
# this will be appended to a programme's description, maybe use starting newline(s)
requests_enabled_description = """

Request lines open! Make this program YOURS by adding a request.
Go to {request_url}, click on ›Request Song‹ and select your favorite."""

# Text to add to a programme listing if it is a syndicated playlist.
# (source: remote_url). Only works with API key.

# this will be used as a programme's title
remote_title = "{playlist}"
# this will be used as a programme's subtitle
remote_subtitle = ""
# this will be APPENDED to a programme's description
remote_description = """

(Syndicated content.)"""

# "Live" text to be shown when a streamer/DJ transmits a scheduled show

# this will be used as a programme's title
live_title = "Live: {presenter}"
# this will be used as a programme's subtitle
live_subtitle = ""
# this will be APPENDED to a programme's description
# REMOVE {comments} if you use that field for internal remarks, else you LEAK INTERNALS!
live_description = """

Live Show on {station_name}, hosted by {presenter}.
{comments}"""

# "Gap Filler" text to be shown when a programme is actually a gap filler.
# After parsing, the gap_filler_title will be used as playlist name and the result
# RE-PARSED by the requests_enabled parser, if ANY of the involved playlists has
# requests enabled. Descriptions from here and the requests enabled parsing will
# be APPENDED to each other (the request text coming beneath).

# this will be used as a programme's title
gap_filler_title = "24/7 Rock"
# this will be used as a programme's subtitle
gap_filler_subtitle = "{playlists}"
# this will be the programme's description
# Your text should make sense even if {playlists} is empty!
# Multiple successive blanks will be automatically replaced by a single blank.
gap_filler_description = """Your favorite sound, 24 hours a day, 7 days a week.
The best {playlists} in {year} — just here, on {station_name}."""

# Text to be appended to EVERY programme description (seldom needed)
append_to_description = """

Program Copyright © {year} {station_name} — {station_description}
Visit us on {station_website}"""

# -a/--apikey option default:
# Add an AzuraCast API key here for extended functionality
# An API key is needed to include streams hidden from public pages,
# like an extra video stream.
api_key = ''

# -p/--public option default:
# If 'public_only' is True, we will only list stations and mounts marked as public.
public_only = False

# -m/--m3u option default:
# No need to recreate the XMLTV M3U Tuner file if only updating the EPG.
# You WILL need to use the -u/--m3u option to initially create the tuner file,
# or when you have made changes to the streams in AzuraCast.
make_m3u = False

# -i/--icon option default:
# You can provide a channel icon, for example from the station's web page.
# If omitted, we will use the station's Default Album Art (set in "Branding").
channel_icon_url = ''

# -c/--customplayer option default:
# You can provide another than the standard web player URL,
# for example a customized web player on the station's web page.
# If omitted, we will use the station's default web player URL.
custom_player_url = ''

# -o/--output option default:
# If you don't want files to be written into the current folder,
# specify an output folder here.
output_folder = '.'

# -d/--days option default:
# EPG for how many days?
num_days = 7

# -f/--fillgaps option default:
# Fill gaps in a station's programmes (True/False)?
fill_gaps = False

# -t/--tvgurl option default.
# Add 'url-tvg' and 'x-tvg-url' tags to M3U files?
# Only makes sense if files are available under '/xmltv' on your AzuraCast server,
# i.e. like 'https://example.com/xmltv/example.com.xml'.
add_tvg_url = False

# *** END OF USER CONFIGURABLE DEFAULTS -- DO NOT MODIFY ANYTHING BELOW ***


def eprint(*args, **kwargs):
    """print error messages to stderr"""
    print(*args, file=sys.stderr, **kwargs)


try:
    import os
    import requests
    import json
    import lxml.etree as et
    import tzlocal
    import datetime as dt
    from urllib.parse import urlparse
    import argparse
except Exception as error:
    eprint("Error:", type(error).__name__, "–", error)
    exit(1)


class azuracast_api():
    """AzuraCast API interface"""

    def __init__(self, instance_url, api_key='', timeout=30):
        self.instance_url = instance_url
        self.api_key = api_key
        self.timeout = timeout  # default None = until connection closed
        self.status_code = 0
        self.headers = {
            "User-Agent": f"{APPNAME}/{VERSION} +{APPURL}",
            "accept": "application/json",
            "X-Clacks-Overhead": "GNU Terry Pratchett, Leonard Nimoy"
        }
        if api_key:
            self.headers["X-API-Key"] = api_key

    def get(self, endpoint, params={}, quit_on_error=False):
        try:
            response = requests.get(
                self.instance_url + '/api' + endpoint,
                headers=self.headers,
                params=params,
                timeout=self.timeout)
            self.status_code = response.status_code
            response.raise_for_status()
        except Exception as error:
            eprint("Error:", type(error).__name__, "–", error)
            if quit_on_error:
                exit(1)
            else:
                return {}

        return response.json()

    def fail(self):
        return self.status_code != 200


def sanitize(name):
    """Sanitize a station shortname to become RFC2838-compliant"""
    # strip, replace ' ' & '_' with '-' (no '_' allowed in domains)
    name = name.strip().translate(str.maketrans(' _', '--'))
    keep = '-.'
    # remove everything that isn't alphanumeric (Unicode-aware) or to be kept
    return ''.join(c for c in name if c.isalnum() or c in keep)


def clean(description):
    """Remove all leftover whitespace from a programme description, not using re"""
    text = description.strip()
    lines = [line.split() for line in text.splitlines()]
    return '\n'.join(' '.join(word for word in line) for line in lines)


def replace_vars(dictionary, text):
    """replace moustache-type variables in text"""
    # The dictionary is a simple key, value dict like so:
    # {
    #   "{variable1}": "replacement text 1",
    #   "{variable2}": "replacement 2"
    # }
    for variable in dictionary:
        if dictionary[variable]:
            text = text.replace(variable, dictionary[variable])
        else:
            # replace with an empty string if Falsy (i.e. JSON null from API)
            text = text.replace(variable, '')
    return text


def get_stations(api, channel_icon_url='', public_only=True):
    """Get station info from this instance"""
    stations = []

    r = api.get('/stations')

    for station in r:
        # get station's default album art; we use this as station logo
        # we use a little trick here by requesting the artwork for non-existing medium "0",
        # which will cause AzuraCast to look up station branding and
        # instance branding for a replacement. It returns the actual image, not a URL.
        if channel_icon_url:
            channel_icon = channel_icon_url
        else:
            channel_icon = api.instance_url + \
                '/api/station/' + str(station["id"]) + '/art/0'
        s = {
            "id": station["id"],
            "channel_id": sanitize(station["shortcode"]) + '.' + urlparse(instance_url).hostname,
            "icon": channel_icon,  # not yet from API
            "name": station["name"],
            "shortcode": station["shortcode"],
            "description": station["description"],
            "is_public": station["is_public"],
            "url": station["url"],
            "public_player_url": custom_player_url if custom_player_url else station["public_player_url"],
            "mounts": [],
            "playlists": [],
            "streamers": []
        }

        # if an API key is given, we can provide a much richer output, notably:
        #   - include mounts not visible on public pages (like a video stream)
        #   - show if listener requests are allowed in programmes (from playlists)
        #   - show presenter info (like a streamer image) in programmes (from streamers)
        if api.api_key:

            # get mount info, to include otherwise invisible mounts
            rm = api.get(
                '/station/' + str(station["id"]) + '/mounts', quit_on_error=True)

            for mount in rm:
                m = {
                    "id": mount["id"],
                    "name": mount["display_name"],
                    "is_public": mount["is_public"],
                    "is_default": mount["is_default"],
                    "url": mount["links"]["listen"]
                }
                if public_only:
                    if mount["is_public"]:
                        s["mounts"].append(m)
                else:
                    s["mounts"].append(m)

            # get playlist info, to later show if listener requests are allowed
            # in the programme items
            rp = api.get(
                '/station/' + str(station["id"]) + '/playlists')

            for playlist in rp:
                p = {
                    "id": playlist["id"],
                    "name": playlist["name"],
                    "type": playlist["type"],
                    "source": playlist["source"],
                    "remote_url": playlist["remote_url"],
                    "is_jingle": playlist["is_jingle"],
                    "include_in_on_demand": playlist["include_in_on_demand"],
                    "include_in_requests": playlist["include_in_requests"],
                    "is_scheduled": playlist["schedule_items"] != []
                }
                if playlist["is_enabled"]:
                    s["playlists"].append(p)

            # get streamer info, to include image in programme's presenter info
            rs = api.get(
                '/station/' + str(station["id"]) + '/streamers')

            for streamer in rs:
                dj = {
                    "id": streamer["id"],
                    "streamer_username": streamer["streamer_username"],
                    "name": streamer["display_name"],
                    "art": streamer["art"],
                    # Be careful: UI says "INTERNAL commments ony",
                    # but _could_ be used for a description
                    "comments": streamer["comments"]
                }
                s["streamers"].append(dj)

        else:

            # no API key, just use the visible standard mounts
            for mount in station["mounts"]:
                m = {
                    "id": mount["id"],
                    "name": mount["name"],
                    "is_default": mount["is_default"],
                    "url": mount["url"]
                }
                s["mounts"].append(m)

        if station["hls_enabled"] == True:
            # HLS has no "is_default", we simply set it to False
            m = {
                "name": station["name"] + " (HLS)",
                "url": station["hls_url"],
                "is_default": False
            }
            s["mounts"].append(m)

        # sort mounts by display name, put default mount at beginning
        # this is intended for players that immediately start playout,
        # and for better human readability
        s["mounts"] = sorted(s["mounts"], key=lambda k: (
            not k["is_default"], k["name"]))

        if public_only:
            if station["is_public"]:
                stations.append(s)
        else:
            stations.append(s)

    return stations


def create_m3u(instance_url, station, output_folder='', add_tvg_url=False):
    """Create an M3U playlist for a single station"""

    # create outfile from folder + station shortname + '.m3u'
    outfile = output_folder+sanitize(station["shortcode"])+".m3u"
    print(f"Writing XMLTV Tuner file (M3U playlist): {outfile}")

    with open(outfile, 'w') as f:
        if add_tvg_url:
            # -t/-tvgurl option: add links to the EPG on the '#EXTM3U' line; MUST be reachable under /xmltv
            tvg_url = instance_url + '/xmltv/' + \
                urlparse(instance_url).hostname+'.xml'
            f.write(f'#EXTM3U url-tvg="{tvg_url}" x-tvg-url="{tvg_url}"\n')
        else:
            # no links
            f.write('#EXTM3U\n')
        for mount in station["mounts"]:
            f.write(
                f'#EXTINF:-1 tvg-name="{mount["name"]}" tvg-id="{station["channel_id"]}" group-title="{station["name"]}" tvg-logo="{station["icon"]}",{mount["name"]}\n')
            f.write(mount['url']+'\n')


def create_gap_fillers(station, programmes):
    """Find gaps between programmes, return list of "gap filler" entries"""

    if len(programmes) <= 1:
        return []

    # find playlists that constitute the general rotation
    # (enabled, type default, not on schedule)
    pl = [item for item in station["playlists"] if item["type"]
          == "default" and not item["is_scheduled"]]

    # make a comma-separated string where the last element is separated by '&' instead
    # ex: '', 'a', 'a & b', 'a, b & c', ...
    names = [item["name"] for item in pl]
    playlists = ' & '.join(filter(None, [', '.join(names[:-1])] + names[-1:]))

    # see if any of them have requests enabled
    requests_enabled = any(
        [item for item in pl if item["include_in_requests"]])

    # sort by start times
    programmes = sorted(programmes, key=lambda x: x['start'])

    # set up text replacers
    replacers = {
        "{playlists}": playlists,
        "{request_url}": station["public_player_url"],
        "{station_name}": station["name"],
        "{station_description}": station["description"],
        "{station_website}": station["url"],
        "{player_url}": station["public_player_url"]
    }

    gaps = []

    # start at the end of the first range
    now = programmes[0]['stop']

    # iterate through programmes, ignoring the first range
    for pair in programmes[1:]:
        # if next start time is before current stop time, keep going until we find a gap
        # if next start time is after current end time, found the first gap
        if pair['start'] > now:
            # create a new gap filler programme
            # use programme's start year for '{year}'
            replacers["{year}"] = pair["start"][0:4]
            p = {
                "channel": station["channel_id"],
                "start": now,
                "stop": pair["start"],
                "title": replace_vars(replacers, gap_filler_title),
                "sub-title": replace_vars(replacers, gap_filler_subtitle),
                "desc": replace_vars(replacers, gap_filler_description),
                "category": category,
                "credits": []
            }
            # parse again if listener requests enabled
            if requests_enabled:
                replacers["{playlist}"] = p["title"]
                p["title"] = replace_vars(replacers, requests_enabled_title)
                p["sub-title"] = replace_vars(replacers,
                                              requests_enabled_subtitle)
                p["desc"] = p["desc"] + \
                    replace_vars(replacers, requests_enabled_description)

            # add extra info to description
            p["desc"] = p["desc"].rstrip() + replace_vars(replacers,
                                                          append_to_description)

            # remove leftover whitespace from description
            p["desc"] = clean(p["desc"])

            gaps.append(p)

        # need to advance 'now' only if the next end time is past the current end time
        now = max(pair['stop'], now)

    return gaps


def get_programme(api, station, num_days=num_days, fill_gaps=False):
    """Get a channel's programme"""

    programmes = []

    # this is currently sub-optimal: The AzuraCast API only returns data
    # for the requested start day and the next.
    # It would be better if we could specify the number of days instead of rows.
    # We fake this by making several requests, one for every 2 days.
    # We also don't care about duplicates -- the parsing is just too much,
    # let the client sort it out.

    local_timezone = tzlocal.get_localzone()
    rows = 100  # number of rows the API shall return, per 2 day result

    # start today at midnight
    today = dt.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)

    for day in range(0, num_days, 2):
        start = today + dt.timedelta(days=day)
        # generate utc offset with colon ourselves, using "%:z" doesn't work everywhere
        utc_offset = start.astimezone(local_timezone).strftime("%z")
        utc_offset = utc_offset[0:3] + ':' + utc_offset[3:]
        start = start.astimezone(local_timezone).strftime(
            "%Y-%m-%dT%H:%M:%S") + utc_offset

        params = {
            "now": start,
            "rows": rows
        }
        r = api.get(
            '/station/' + str(station["id"]) + '/schedule', params=params)
        if api.fail():
            return programmes

        for r_pgm in r:
            p = {
                "id": r_pgm["id"],
                "type": r_pgm["type"],
                "channel": station["channel_id"],
                "start": dt.datetime.strptime(r_pgm["start"], "%Y-%m-%dT%H:%M:%S%z").astimezone(local_timezone).strftime("%Y%m%d%H%M%S %z"),
                "stop": dt.datetime.strptime(r_pgm["end"], "%Y-%m-%dT%H:%M:%S%z").astimezone(local_timezone).strftime("%Y%m%d%H%M%S %z"),
                "title": r_pgm["title"],
                "sub-title": "",
                "desc": r_pgm["description"],
                "category": category,
                "credits": []
            }

            # try to enrich programme with playlist info
            if r_pgm["type"] == "playlist":
                # try to find the corresponding playlist by name (sadly, no ID)
                pl = next(
                    (item for item in station["playlists"] if item["name"] == r_pgm["name"]), None)

                # playlist has listener requests enabled, enrich title, sub-title, and description
                if pl and pl["include_in_requests"]:
                    replacers = {
                        "{playlist}": pl["name"],
                        "{request_url}": station["public_player_url"],
                        "{station_name}": station["name"],
                        "{station_description}": station["description"],
                        "{station_website}": station["url"],
                        "{player_url}": station["public_player_url"],
                        "{year}": r_pgm["start"][0:4]
                    }
                    p["title"] = replace_vars(
                        replacers, requests_enabled_title)
                    p["sub-title"] = replace_vars(replacers,
                                                  requests_enabled_subtitle)
                    p["desc"] = r_pgm["description"].rstrip(
                    ) + replace_vars(replacers, requests_enabled_description)

                # playlist is syndicated content (remote)
                if pl and pl["source"] == "remote_url":
                    replacers = {
                        "{playlist}": pl["name"],
                        "{remote_url}": pl["remote_url"],
                        "{station_name}": station["name"],
                        "{station_description}": station["description"],
                        "{station_website}": station["url"],
                        "{player_url}": station["public_player_url"],
                        "{year}": r_pgm["start"][0:4]
                    }
                    p["title"] = replace_vars(replacers, remote_title)
                    p["sub-title"] = replace_vars(replacers, remote_subtitle)
                    p["desc"] = r_pgm["description"].rstrip(
                    ) + replace_vars(replacers, remote_description)

            # try to enrich programme with streamer info
            if r_pgm["type"] == "streamer":
                # try to find the corresponding streamer by name (sadly, no ID)
                dj = next(
                    (item for item in station["streamers"] if item["name"] == r_pgm["name"]), None)

                if dj:
                    # found the streamer, use their info (and image)
                    replacers = {
                        "{presenter}": dj["name"],
                        "{image_url}": dj["art"],
                        "{comments}": dj["comments"],
                        "{station_name}": station["name"],
                        "{station_description}": station["description"],
                        "{station_website}": station["url"],
                        "{player_url}": station["public_player_url"],
                        "{year}": r_pgm["start"][0:4]
                    }

                    p["title"] = replace_vars(replacers, live_title)
                    p["sub-title"] = replace_vars(replacers, live_subtitle)
                    p["desc"] = r_pgm["description"].rstrip(
                    ) + replace_vars(replacers, live_description)
                    p["credits"].append(
                        {"presenter": {"name": dj["name"], "image": dj["art"]}})
                else:
                    # streamer not provided, make for some general niceness
                    replacers = {
                        "{presenter}": r_pgm["name"],
                        "{image_url}": '',
                        "{comments}": '',
                        "{station_name}": station["name"],
                        "{station_description}": station["description"],
                        "{station_website}": station["url"],
                        "{player_url}": station["public_player_url"],
                        "{year}": r_pgm["start"][0:4]
                    }
                    p["title"] = replace_vars(replacers, live_title)
                    p["sub-title"] = replace_vars(replacers, live_subtitle)
                    p["desc"] = r_pgm["description"].rstrip(
                    ) + replace_vars(replacers, live_description)
                    p["credits"].append({"presenter": {"name": r_pgm["name"]}})

            # add extra info to description
            replacers = {
                "{station_name}": station["name"],
                "{station_description}": station["description"],
                "{station_website}": station["url"],
                "{player_url}": station["public_player_url"],
                "{year}": r_pgm["start"][0:4]
            }
            p["desc"] = p["desc"].rstrip() + replace_vars(replacers,
                                                          append_to_description)

            # remove extra whitespace from description
            p["desc"] = clean(p["desc"])

            programmes.append(p)

    # and here starts the tedious work of removing the duplicates...
    # de-duplicate using a set (returns an unsorted list!)
    set_of_jsons = {json.dumps(d, sort_keys=True) for d in programmes}
    programmes = [json.loads(t) for t in set_of_jsons]

    # fill any gaps between programmes, if so requested
    if fill_gaps:
        programmes = programmes + create_gap_fillers(station, programmes)

    # sort by start time
    programmes = sorted(programmes, key=lambda k: k['start'])

    return programmes


def create_xmltv(instance_url, stations, programmes, output_folder=''):
    """Create an XMLTV EPG for all stations"""

    # create outfile from folder + domain.name + '.xml'
    outfile = output_folder+urlparse(instance_url).hostname+'.xml'
    print(f"Writing XMLTV EPG file: {outfile}")

    # set up the root
    local_timezone = tzlocal.get_localzone()
    date = dt.datetime.now().astimezone(local_timezone).strftime("%Y%m%d%H%M%S %z")

    root = et.Element("tv",
                      attrib={"date": date,
                              "source-info-url": instance_url,
                              "source-info-name": urlparse(instance_url).netloc,
                              "generator-info-name": APPNAME + ' ' + VERSION,
                              "generator-info-url": APPURL
                              })

    # set up the channels
    for station in stations:
        channel = et.SubElement(root, "channel", attrib={
                                "id": station["channel_id"]})
        et.SubElement(channel, "display-name").text = station["name"]
        if station["icon"]:
            et.SubElement(channel, "icon", attrib={"src": station["icon"]})

    # set up programs
    for s_pgm in programmes:
        for r_pgm in s_pgm:
            attrib_lang = {"lang": "en"}
            programme_attrib = dict(
                start=r_pgm["start"],
                stop=r_pgm["stop"],
                channel=r_pgm["channel"])
            programme = et.SubElement(
                root, "programme", attrib=programme_attrib)
            et.SubElement(programme, "title",
                          attrib=attrib_lang).text = r_pgm["title"]
            # leave out empty subtitles since some programs throw warnings
            if r_pgm["sub-title"]:
                et.SubElement(programme, "sub-title",
                              attrib=attrib_lang).text = r_pgm["sub-title"]
            et.SubElement(programme, "desc",
                          attrib=attrib_lang).text = r_pgm["desc"]

            credits = et.SubElement(programme, "credits")
            for c in r_pgm["credits"]:
                for k, v in c.items():
                    credit = et.SubElement(credits, k)
                    credit.text = v["name"]
                    for k1, v1 in v.items():
                        if k1 == "image":
                            et.SubElement(credit, k1, attrib={
                                          "type": "person"}).text = v1

            et.SubElement(programme, "category",
                          attrib=attrib_lang).text = r_pgm["category"]

    with et.xmlfile(outfile, encoding="UTF-8") as xf:
        xf.write_declaration()
        xf.write_doctype('<!DOCTYPE tv SYSTEM "xmltv.dtd">')
        xf.write(root, pretty_print=True)


# some tests for arparse

def my_url(arg):
    """Check if valid URL given"""
    url = urlparse(arg)
    if all((url.scheme, url.netloc)):
        return arg
    raise argparse.ArgumentTypeError('Invalid URL')


def my_url_path(arg):
    """Check if valid icon URL given"""
    url = urlparse(arg)
    if arg == '' or all((url.scheme, url.netloc, url.path)):
        return arg
    raise argparse.ArgumentTypeError('Invalid URL (requires path)')


def my_path(arg):
    """Check for valid output file path"""
    arg = os.path.normpath(arg)
    if os.path.isdir(arg):
        return arg
    raise NotADirectoryError(arg)


parser = argparse.ArgumentParser(description='Create XMLTV Tuner and EPG files from an AzuraCast Web Radio.',
                                 epilog=f"""
%(prog)s can create XMLTV M3U Tuner files and XML EPG files for both
your own and other AzuraCast stations.

For much better programme data to be generated, create an AzuraCast API key
and use the -a/--apikey option, which allows:
  - using otherwise invisible mounts, like an added video stream,
  - showing listener request info if a playlist has requests enabled
  - adding a presenter image on live shows, and (mis-)using the
    streamer comment field as a description
  - showing extra info for syndicated content (remote playlists)

The -t/--tvgurl option adds 'url-tvg' and 'x-tvg-url' tags to the M3U Tuner
files. This helps media center software like KODI to automatically locate the
corresponding EPG data file, but only works if the generated M3U and XML files
are available under the '/xmltv' path of your AzuraCast server.
See installation instructions at {APPURL}.

Edit '{argparse._sys.argv[0]}' using a text editor
to change some defaults near the top of the file.

Please report any issues to {APPURL}/issues.""",
                                 formatter_class=argparse.RawDescriptionHelpFormatter)  # ArgumentDefaultsHelpFormatter
parser.add_argument('-v', '--version', action='version',
                    version='%(prog)s ' + __version__)
parser.add_argument('-u', '--url', type=my_url, default=instance_url,
                    help='base URL to an AzuraCast instance')
parser.add_argument('-i', '--icon', metavar='URL', type=my_url_path, default=channel_icon_url,
                    help='URL to a channel icon; will use station\'s default album art if omitted')
parser.add_argument('-c', '--customplayer', metavar='URL', type=my_url_path, default=custom_player_url,
                    help='URL to a custom web player; modifies {player_url} and {request_url} variables')
parser.add_argument('-d', '--days', type=int, default=num_days,
                    help='number of days to include in the EPG')
parser.add_argument('-f', '--fillgaps', action='store_true',
                    default=fill_gaps, help='fill gaps between programmes with a \'General Rotation\' entry')
parser.add_argument('-o', '--output', metavar='FOLDER', type=my_path,
                    default=output_folder, help='output folder for XMLTV files')
parser.add_argument('-a', '--apikey', default=api_key,
                    help='AzuraCast API key; allows creating much better EPG data, see below')
parser.add_argument('-p', '--public', action='store_true',
                    default=public_only, help='include only public stations & streams')
parser.add_argument('-m', '--m3u', action='store_true', default=make_m3u,
                    help='create M3U XMLTV Tuner file(s); only needed on first run or after changes in AzuraCast')
parser.add_argument('-t', '--tvgurl', action='store_true', default=add_tvg_url,
                    help='add \'tvg-url\' tags to M3U file; allows software to find the corresponding EPG automatically (see below)')

args = parser.parse_args()

instance_url = args.url
api_key = args.apikey
public_only = args.public
output_folder = args.output + '/'
make_m3u = args.m3u
channel_icon_url = args.icon
custom_player_url = args.customplayer
num_days = args.days
fill_gaps = args.fillgaps
add_tvg_url = args.tvgurl

# Init the AzuraCast API
api = azuracast_api(instance_url, api_key)

# Get stations from this AzuraCast instance
stations = get_stations(
    api, channel_icon_url=channel_icon_url, public_only=public_only)

# Create M3U playlist files
if make_m3u:
    for station in stations:
        create_m3u(instance_url, station,
                   output_folder=output_folder, add_tvg_url=add_tvg_url)

# Get schedules from all stations
programmes = []
for station in stations:
    programmes.append(get_programme(api, station, num_days, fill_gaps))

# Create XMLTV file
create_xmltv(instance_url, stations, programmes, output_folder=output_folder)
